#!/usr/bin/env ruby

# frozen_string_literal: true

puts "Wolfgang Copyright (C) 2019 Piers Holt\n"\
     "This program comes with ABSOLUTELY NO WARRANTY.\n"\
     "This is free software, and you are welcome to redistribute it\n"\
     'under certain conditions.'

# *************************************************************************** #
#                                  LOAD PATHS                                 #
# *************************************************************************** #
begin
  require 'rubygems'
  require 'bundler/setup'

  require 'pry-byebug'

  require 'walter/shared/log_actually'
  require 'walter/shared/yabber'

  # Setup load path for application (makes you realise RubyGems spoils you...)
  def setup_path(dir)
    load_path = File.expand_path(File.dirname(__FILE__) + "/../#{dir}")
    $LOAD_PATH.unshift(load_path) unless $LOAD_PATH.include?(load_path)
  rescue StandardError => e
    puts e
    e.backtrace.each { |line| puts line }
    exit
  end

  setup_path('lib')
rescue LoadError => e
  # LogActually.default.error('run') { e }
  puts e
  e.backtrace.each { |line| puts line }
  $LOAD_PATH.each { |line| puts line }
  exit
rescue StandardError => e
  puts e
  e.backtrace.each { |line| puts line }
end

begin
  LOGGER = LogActually.is_all_around(:default)
  LogActually.default.i

  # Bluez
  LogActually.is_all_around(:service)
  LogActually.service.i

  # Core Objects
  LogActually.is_all_around(:object_manager)
  LogActually.object_manager.i
  LogActually.is_all_around(:properties)
  LogActually.properties.i

  # Objects
  LogActually.is_all_around(:controller)
  LogActually.controller.i
  LogActually.is_all_around(:device)
  LogActually.device.i

  # Interfaces
  LogActually.is_all_around(:media_transport)
  LogActually.media_transport.i
  LogActually.is_all_around(:media_player)
  LogActually.media_player.i
  LogActually.is_all_around(:media_browser)
  LogActually.media_browser.i

  # Bluetooth Profiles
  LogActually.is_all_around(:core)
  LogActually.core.i
  LogActually.is_all_around(:avrcp)
  LogActually.avrcp.i

  # Car Kit
  LogActually.is_all_around(:notifications)
  LogActually.notifications.i
  LogActually.is_all_around(:commands)
  LogActually.commands.i

  # Yabber
  LogActually.messaging.d
  LogActually.publisher.d
  LogActually.subscriber.d
  LogActually.client.d
  LogActually.server.d
rescue LoadError => e
  LOGGER.error('bin') { 'Dependencies load error!' }
  LOGGER.error('bin') { e }
  e.backtrace.each { |line| LOGGER.error('bin') { line } }
  LOGGER.error('bin') { lib_path }
rescue StandardError => e
  LOGGER.error('bin') { 'Dependencies standard error?' }
  LOGGER.error('bin') { e }
  e.backtrace.each { |line| LOGGER.error('bin') { line } }
  LOGGER.error('bin') { lib_path }
rescue Interrupt
  Signal.trap(0, proc { puts "Terminating: #{$$}" })
  # LOGGER.close
  exit
# ensure
#   exit
end

# LOGGER = get_logger

LOGGER.debug('bin') { 'Require local dependencies' }

begin

  require '1-dbus-decorator/dbus-decorator'
  require '2-bluez-dbus/bluez-dbus'
  require '3-bluez-manager/bluez-manager'
  require '3-bluetooth-profiles/bluetooth-profiles'
  require '6-virtual-car-kit/virtual-car-kit'
rescue LoadError => e
  LOGGER.error('bin') { 'Dependencies load error!' }
  LOGGER.error('bin') { e }
  e.backtrace.each { |line| LOGGER.error('bin') { line } }
  LOGGER.error('bin') { lib_path }
  quit
rescue StandardError => e
  LOGGER.error('bin') { 'Dependencies standard error?' }
  LOGGER.error('bin') { e }
  e.backtrace.each { |line| LOGGER.error('bin') { line } }
  LOGGER.error('bin') { lib_path }
  quit
end

begin
  t = Thread.current
  t[:name] = 'Main Thread'
  LOGGER.info('bin') { 'Starting Publisher...' }
  # Publisher.announcement(:wolfgang)
  Publisher.wolfgang
  LOGGER.info('bin') { 'Starting Server...' }
  Server.wolfgang!
  LOGGER.info('bin') { 'Delay...' }
  sleep(3)
  LOGGER.info('bin') { 'Starting VirtualCarKit' }
  virtual_car_kit = VirtualCarKit.new
  virtual_car_kit.start
rescue StandardError => e
  LOGGER.error('bin') { 'Error starting app' }
  LOGGER.error('bin') { e }
  e.backtrace.each { |line| LOGGER.error('bin') { line } }
end

LOGGER.info('bin') { 'All over, red rover' }

exit
